/*
 * WebRTC-HTTP ingestion protocol (WHIP) muxer
 * Copyright (c) 2023 The FFmpeg Project
 *
 * This file is part of FFmpeg.
 *
 * FFmpeg is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * FFmpeg is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with FFmpeg; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <openssl/ssl.h>
#include <openssl/err.h>

#include "dtls.h"
#include "libavutil/bprint.h"
#include "libavutil/intreadwrite.h"
#include "libavutil/random_seed.h"
#include "libavutil/time.h"
#include "internal.h"
#include "network.h"

/**
 * The DTLS content type.
 * See https://tools.ietf.org/html/rfc2246#section-6.2.1
 * change_cipher_spec(20), alert(21), handshake(22), application_data(23)
 */
#define DTLS_CONTENT_TYPE_CHANGE_CIPHER_SPEC 20

/**
 * The DTLS record layer header has a total size of 13 bytes, consisting of
 * ContentType (1 byte), ProtocolVersion (2 bytes), Epoch (2 bytes),
 * SequenceNumber (6 bytes), and Length (2 bytes).
 * See https://datatracker.ietf.org/doc/html/rfc9147#section-4
 */
#define DTLS_RECORD_LAYER_HEADER_LEN 13

/**
 * The DTLS version number, which is 0xfeff for DTLS 1.0, or 0xfefd for DTLS 1.2.
 * See https://datatracker.ietf.org/doc/html/rfc9147#name-the-dtls-record-layer
 */
#define DTLS_VERSION_10 0xfeff
#define DTLS_VERSION_12 0xfefd

/**
 * Maximum size limit of a certificate and private key size.
 */
#define DTLS_MAX_CERTIFICATE_SIZE 8192

typedef struct DTLSContext {
    AVClass *av_class;

    /* For callback. */
    dtls_fn_on_state on_state;
    dtls_fn_on_write on_write;
    void* opaque;

    /* For logging. */
    AVClass *log_avcl;

    /* The DTLS context. */
    SSL_CTX *dtls_ctx;
    SSL *dtls;
    /* The DTLS BIOs. */
    BIO *bio_in;

    /* The private key for DTLS handshake. */
    EVP_PKEY *dtls_pkey;
    /* The EC key for DTLS handshake. */
    EC_KEY* dtls_eckey;
    /* The SSL certificate used for fingerprint in SDP and DTLS handshake. */
    X509 *dtls_cert;
    /* The fingerprint of certificate, used in SDP offer. */
    char *dtls_fingerprint;

    /**
     * This represents the material used to build the SRTP master key. It is
     * generated by DTLS and has the following layout:
     *          16B         16B         14B             14B
     *      client_key | server_key | client_salt | server_salt
     */
    uint8_t dtls_srtp_materials[(DTLS_SRTP_KEY_LEN + DTLS_SRTP_SALT_LEN) * 2];

    /* Whether the DTLS is done at least for us. */
    int dtls_done_for_us;
    /* Whether the SRTP key is exported. */
    int dtls_srtp_key_exported;
    /* The number of packets retransmitted for DTLS. */
    int dtls_arq_packets;
    /**
     * This is the last DTLS content type and handshake type that is used to detect
     * the ARQ packet.
     */
    uint8_t dtls_last_content_type;
    uint8_t dtls_last_handshake_type;

    /* These variables represent timestamps used for calculating and tracking the cost. */
    int64_t dtls_init_starttime;
    int64_t dtls_init_endtime;
    int64_t dtls_handshake_starttime;
    int64_t dtls_handshake_endtime;

    /* Helper for get error code and message. */
    int error_code;
    char error_message[256];

    /* The certificate and private key used for DTLS handshake. */
    char* cert_file;
    char* key_file;
    /**
     * The size of RTP packet, should generally be set to MTU.
     * Note that pion requires a smaller value, for example, 1200.
     */
    int mtu;
} DTLSContext;

/**
 * Read all data from the given URL url and store it in the given buffer bp.
 */
static int dtls_url_read_all(AVFormatContext *s, const char *url, AVBPrint *bp)
{
    int ret = 0;
    AVDictionary *opts = NULL;
    URLContext *uc = NULL;
    char buf[MAX_URL_SIZE];

    ret = ffurl_open_whitelist(&uc, url, AVIO_FLAG_READ, &s->interrupt_callback,
                               &opts, s->protocol_whitelist, s->protocol_blacklist, NULL);
    if (ret < 0) {
        av_log(s, AV_LOG_ERROR, "WHIP: Failed to open url %s\n", url);
        goto end;
    }

    while (1) {
        ret = ffurl_read(uc, buf, sizeof(buf));
        if (ret == AVERROR_EOF) {
            /* Reset the error because we read all response as answer util EOF. */
            ret = 0;
            break;
        }
        if (ret <= 0) {
            av_log(s, AV_LOG_ERROR, "WHIP: Failed to read from url=%s, key is %s\n", url, bp->str);
            goto end;
        }

        av_bprintf(bp, "%.*s", ret, buf);
        if (!av_bprint_is_complete(bp)) {
            av_log(s, AV_LOG_ERROR, "WHIP: Exceed max size %.*s, %s\n", ret, buf, bp->str);
            ret = AVERROR(EIO);
            goto end;
        }
    }

    end:
    ffurl_closep(&uc);
    av_dict_free(&opts);
    return ret;
}

char* dtls_get_fingerprint(void *pctx)
{
    DTLSContext *ctx = pctx;
    return ctx->dtls_fingerprint;
}

uint8_t* dtls_get_srtp_client_key(void *pctx)
{
    DTLSContext *ctx = pctx;
    return ctx->dtls_srtp_materials;
}

uint8_t* dtls_get_srtp_server_key(void *pctx)
{
    return dtls_get_srtp_client_key(pctx) + DTLS_SRTP_KEY_LEN;
}

uint8_t* dtls_get_srtp_client_salt(void *pctx)
{
    return dtls_get_srtp_server_key(pctx) + DTLS_SRTP_KEY_LEN;
}

uint8_t* dtls_get_srtp_server_salt(void *pctx)
{
    return dtls_get_srtp_client_salt(pctx) + DTLS_SRTP_SALT_LEN;
}

/**
 * Whether the packet is a DTLS packet.
 */
int dtls_can_handle_packet(uint8_t *b, int size)
{
    uint16_t version = AV_RB16(&b[1]);
    return size > DTLS_RECORD_LAYER_HEADER_LEN &&
           b[0] >= DTLS_CONTENT_TYPE_CHANGE_CIPHER_SPEC &&
           (version == DTLS_VERSION_10 || version == DTLS_VERSION_12);
}

/**
 * Retrieves the error message for the latest OpenSSL error.
 *
 * This function retrieves the error code from the thread's error queue, converts it
 * to a human-readable string, and stores it in the DTLSContext's error_message field.
 * The error queue is then cleared using ERR_clear_error().
 */
static const char* openssl_get_error(DTLSContext *ctx)
{
    int r2 = ERR_get_error();
    if (r2)
        ERR_error_string_n(r2, ctx->error_message, sizeof(ctx->error_message));
    else
        ctx->error_message[0] = '\0';

    ERR_clear_error();
    return ctx->error_message;
}

/**
 * Get the error code for the given SSL operation result.
 *
 * This function retrieves the error code for the given SSL operation result
 * and stores the error message in the DTLS context if an error occurred.
 * It also clears the error queue.
 */
static int openssl_ssl_get_error(DTLSContext *ctx, int ret)
{
    SSL *dtls = ctx->dtls;
    int r1 = SSL_ERROR_NONE;

    if (ret <= 0)
        r1 = SSL_get_error(dtls, ret);

    openssl_get_error(ctx);
    return r1;
}

/**
 * Callback function to print the OpenSSL SSL status.
 */
static void openssl_dtls_on_info(const SSL *dtls, int where, int r0)
{
    int w, r1, is_fatal, is_warning, is_close_notify;
    const char *method = "undefined", *alert_type, *alert_desc;
    int state;
    DTLSContext *ctx = (DTLSContext*)SSL_get_ex_data(dtls, 0);

    w = where & ~SSL_ST_MASK;
    if (w & SSL_ST_CONNECT)
        method = "SSL_connect";
    else if (w & SSL_ST_ACCEPT)
        method = "SSL_accept";

    r1 = openssl_ssl_get_error(ctx, r0);
    if (where & SSL_CB_LOOP) {
        av_log(ctx, AV_LOG_VERBOSE, "DTLS: Info method=%s state=%s(%s), where=%d, ret=%d, r1=%d\n",
               method, SSL_state_string(dtls), SSL_state_string_long(dtls), where, r0, r1);
    } else if (where & SSL_CB_ALERT) {
        method = (where & SSL_CB_READ) ? "read":"write";

        alert_type = SSL_alert_type_string_long(r0);
        alert_desc = SSL_alert_desc_string(r0);

        if (!av_strcasecmp(alert_type, "warning") && !av_strcasecmp(alert_desc, "CN"))
            av_log(ctx, AV_LOG_WARNING, "DTLS: SSL3 alert method=%s type=%s, desc=%s(%s), where=%d, ret=%d, r1=%d\n",
                   method, alert_type, alert_desc, SSL_alert_desc_string_long(r0), where, r0, r1);
        else
            av_log(ctx, AV_LOG_ERROR, "DTLS: SSL3 alert method=%s type=%s, desc=%s(%s), where=%d, ret=%d, r1=%d %s\n",
                   method, alert_type, alert_desc, SSL_alert_desc_string_long(r0), where, r0, r1, ctx->error_message);

        /**
         * Notify the DTLS to handle the ALERT message, which maybe means media connection disconnect.
         * CN(Close Notify) is sent when peer close the PeerConnection. fatal, IP(Illegal Parameter)
         * is sent when DTLS failed.
         */
        is_fatal = !av_strncasecmp(alert_type, "fatal", 5);
        is_warning = !av_strncasecmp(alert_type, "warning", 7);
        is_close_notify = !av_strncasecmp(alert_desc, "CN", 2);
        state = is_fatal ? DTLS_STATE_FAILED : (is_warning && is_close_notify ? DTLS_STATE_CLOSED : DTLS_STATE_NONE);
        if (state != DTLS_STATE_NONE && ctx->on_state) {
            av_log(ctx, AV_LOG_INFO, "DTLS: Notify ctx=%p, state=%d, fatal=%d, warning=%d, cn=%d\n",
                   ctx, state, is_fatal, is_warning, is_close_notify);
            ctx->on_state(ctx, ctx->opaque, state, alert_type, alert_desc);
        }
    } else if (where & SSL_CB_EXIT) {
        if (!r0)
            av_log(ctx, AV_LOG_WARNING, "DTLS: Fail method=%s state=%s(%s), where=%d, ret=%d, r1=%d\n",
                   method, SSL_state_string(dtls), SSL_state_string_long(dtls), where, r0, r1);
        else if (r0 < 0)
            if (r1 != SSL_ERROR_NONE && r1 != SSL_ERROR_WANT_READ && r1 != SSL_ERROR_WANT_WRITE)
                av_log(ctx, AV_LOG_ERROR, "DTLS: Error method=%s state=%s(%s), where=%d, ret=%d, r1=%d %s\n",
                       method, SSL_state_string(dtls), SSL_state_string_long(dtls), where, r0, r1, ctx->error_message);
            else
                av_log(ctx, AV_LOG_VERBOSE, "DTLS: Info method=%s state=%s(%s), where=%d, ret=%d, r1=%d\n",
                       method, SSL_state_string(dtls), SSL_state_string_long(dtls), where, r0, r1);
    }
}

static void openssl_dtls_state_trace(DTLSContext *ctx, uint8_t *data, int length, int incoming)
{
    uint8_t content_type = 0;
    uint16_t size = 0;
    uint8_t handshake_type = 0;

    /* Change_cipher_spec(20), alert(21), handshake(22), application_data(23) */
    if (length >= 1)
        content_type = AV_RB8(&data[0]);
    if (length >= 13)
        size = AV_RB16(&data[11]);
    if (length >= 14)
        handshake_type = AV_RB8(&data[13]);

    av_log(ctx, AV_LOG_VERBOSE, "DTLS: Trace %s, done=%u, arq=%u, len=%u, cnt=%u, size=%u, hs=%u\n",
           (incoming? "RECV":"SEND"), ctx->dtls_done_for_us, ctx->dtls_arq_packets, length,
           content_type, size, handshake_type);
}

/**
 * Always return 1 to accept any certificate. This is because we allow the peer to
 * use a temporary self-signed certificate for DTLS.
 */
static int openssl_dtls_verify_callback(int preverify_ok, X509_STORE_CTX *ctx)
{
    return 1;
}

/**
 * DTLS BIO read callback.
 */
#if OPENSSL_VERSION_NUMBER < 0x30000000L // v3.0.x
static long openssl_dtls_bio_out_callback(BIO* b, int oper, const char* argp, int argi, long argl, long retvalue)
#else
static long openssl_dtls_bio_out_callback_ex(BIO *b, int oper, const char *argp, size_t len, int argi, long argl, int retvalue, size_t *processed)
#endif
{
    int ret, req_size = argi, is_arq = 0;
    uint8_t content_type, handshake_type;
    uint8_t *data = (uint8_t*)argp;
    DTLSContext* ctx = b ? (DTLSContext*)BIO_get_callback_arg(b) : NULL;

#if OPENSSL_VERSION_NUMBER >= 0x30000000L // v3.0.x
    req_size = len;
    av_log(ctx, AV_LOG_DEBUG, "DTLS: BIO callback b=%p, oper=%d, argp=%p, len=%ld, argi=%d, argl=%ld, retvalue=%d, processed=%p, req_size=%d\n",
           b, oper, argp, len, argi, argl, retvalue, processed, req_size);
#else
    av_log(ctx, AV_LOG_DEBUG, "DTLS: BIO callback b=%p, oper=%d, argp=%p, argi=%d, argl=%ld, retvalue=%ld, req_size=%d\n",
           b, oper, argp, argi, argl, retvalue, req_size);
#endif

    if (oper != BIO_CB_WRITE || !argp || req_size <= 0)
        return retvalue;

    openssl_dtls_state_trace(ctx, data, req_size, 0);
    ret = ctx->on_write ? ctx->on_write(ctx, ctx->opaque, data, req_size) : 0;
    content_type = req_size > 0 ? AV_RB8(&data[0]) : 0;
    handshake_type = req_size > 13 ? AV_RB8(&data[13]) : 0;

    is_arq = ctx->dtls_last_content_type == content_type && ctx->dtls_last_handshake_type == handshake_type;
    ctx->dtls_arq_packets += is_arq;
    ctx->dtls_last_content_type = content_type;
    ctx->dtls_last_handshake_type = handshake_type;

    if (ret < 0) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Send request failed, oper=%d, content=%d, handshake=%d, size=%d, is_arq=%d\n",
               oper, content_type, handshake_type, req_size, is_arq);
        return ret;
    }

    return retvalue;
}

static int openssl_read_certificate(AVFormatContext *s, DTLSContext *ctx)
{
    int ret = 0;
    BIO *key_b = NULL, *cert_b = NULL;
    AVBPrint key_bp, cert_bp;

    /* To prevent a crash during cleanup, always initialize it. */
    av_bprint_init(&key_bp, 1, DTLS_MAX_CERTIFICATE_SIZE);
    av_bprint_init(&cert_bp, 1, DTLS_MAX_CERTIFICATE_SIZE);

    /* Read key file. */
    ret = dtls_url_read_all(s, ctx->key_file, &key_bp);
    if (ret < 0) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to open key file %s\n", ctx->key_file);
        goto end;
    }

    if ((key_b = BIO_new(BIO_s_mem())) == NULL) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    BIO_write(key_b, key_bp.str, key_bp.len);
    ctx->dtls_pkey = PEM_read_bio_PrivateKey(key_b, NULL, NULL, NULL);
    if (!ctx->dtls_pkey) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to read private key from %s\n", ctx->key_file);
        ret = AVERROR(EIO);
        goto end;
    }

    /* Read certificate. */
    ret = dtls_url_read_all(s, ctx->cert_file, &cert_bp);
    if (ret < 0) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to open cert file %s\n", ctx->cert_file);
        goto end;
    }

    if ((cert_b = BIO_new(BIO_s_mem())) == NULL) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    BIO_write(cert_b, cert_bp.str, cert_bp.len);
    ctx->dtls_cert = PEM_read_bio_X509(cert_b, NULL, NULL, NULL);
    if (!ctx->dtls_cert) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to read certificate from %s\n", ctx->cert_file);
        ret = AVERROR(EIO);
        goto end;
    }

    end:
    BIO_free(key_b);
    av_bprint_finalize(&key_bp, NULL);
    BIO_free(cert_b);
    av_bprint_finalize(&cert_bp, NULL);
    return ret;
}

static int openssl_dtls_gen_private_key(DTLSContext *ctx)
{
    int ret = 0;

    /**
     * Note that secp256r1 in openssl is called NID_X9_62_prime256v1 or prime256v1 in string,
     * not NID_secp256k1 or secp256k1 in string.
     *
     * TODO: Should choose the curves in ClientHello.supported_groups, for example:
     *      Supported Group: x25519 (0x001d)
     *      Supported Group: secp256r1 (0x0017)
     *      Supported Group: secp384r1 (0x0018)
     */
#if OPENSSL_VERSION_NUMBER < 0x30000000L /* OpenSSL 3.0 */
    EC_GROUP *ecgroup = NULL;
    int curve = NID_X9_62_prime256v1;
#else
    const char *curve = SN_X9_62_prime256v1;
#endif

#if OPENSSL_VERSION_NUMBER < 0x30000000L /* OpenSSL 3.0 */
    ctx->dtls_pkey = EVP_PKEY_new();
    ctx->dtls_eckey = EC_KEY_new();
    ecgroup = EC_GROUP_new_by_curve_name(curve);
    if (!ecgroup) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Create EC group by curve=%d failed, %s", curve, openssl_get_error(ctx));
        goto einval_end;
    }

#if OPENSSL_VERSION_NUMBER < 0x10100000L // v1.1.x
    /* For openssl 1.0, we must set the group parameters, so that cert is ok. */
    EC_GROUP_set_asn1_flag(ecgroup, OPENSSL_EC_NAMED_CURVE);
#endif

    if (EC_KEY_set_group(ctx->dtls_eckey, ecgroup) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Generate private key, EC_KEY_set_group failed, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (EC_KEY_generate_key(ctx->dtls_eckey) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Generate private key, EC_KEY_generate_key failed, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (EVP_PKEY_set1_EC_KEY(ctx->dtls_pkey, ctx->dtls_eckey) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Generate private key, EVP_PKEY_set1_EC_KEY failed, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }
#else
    ctx->dtls_pkey = EVP_EC_gen(curve);
    if (!ctx->dtls_pkey) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Generate private key, EVP_EC_gen curve=%s failed, %s\n", curve, openssl_get_error(ctx));
        goto einval_end;
    }
#endif
    goto end;

    einval_end:
    ret = AVERROR(EINVAL);
    end:
#if OPENSSL_VERSION_NUMBER < 0x30000000L /* OpenSSL 3.0 */
    EC_GROUP_free(ecgroup);
#endif
    return ret;
}

static int openssl_dtls_gen_certificate(DTLSContext *ctx)
{
    int ret = 0, serial, expire_day, i, n = 0;
    AVBPrint fingerprint;
    unsigned char md[EVP_MAX_MD_SIZE];
    const char *aor = "lavf";
    X509_NAME* subject = NULL;
    X509 *dtls_cert = NULL;

    /* To prevent a crash during cleanup, always initialize it. */
    av_bprint_init(&fingerprint, 1, MAX_URL_SIZE);

    dtls_cert = ctx->dtls_cert = X509_new();
    if (!dtls_cert) {
        goto enomem_end;
    }

    // TODO: Support non-self-signed certificate, for example, load from a file.
    subject = X509_NAME_new();
    if (!subject) {
        goto enomem_end;
    }

    serial = (int)av_get_random_seed();
    if (ASN1_INTEGER_set(X509_get_serialNumber(dtls_cert), serial) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set serial, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (X509_NAME_add_entry_by_txt(subject, "CN", MBSTRING_ASC, aor, strlen(aor), -1, 0) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set CN, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (X509_set_issuer_name(dtls_cert, subject) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set issuer, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }
    if (X509_set_subject_name(dtls_cert, subject) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set subject name, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    expire_day = 365;
    if (!X509_gmtime_adj(X509_get_notBefore(dtls_cert), 0)) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set notBefore, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }
    if (!X509_gmtime_adj(X509_get_notAfter(dtls_cert), 60*60*24*expire_day)) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set notAfter, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (X509_set_version(dtls_cert, 2) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set version, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (X509_set_pubkey(dtls_cert, ctx->dtls_pkey) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to set public key, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    if (!X509_sign(dtls_cert, ctx->dtls_pkey, EVP_sha1())) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to sign certificate, %s\n", openssl_get_error(ctx));
        goto einval_end;
    }

    /* Generate the fingerpint of certficate. */
    if (X509_digest(dtls_cert, EVP_sha256(), md, &n) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to generate fingerprint, %s\n", openssl_get_error(ctx));
        goto eio_end;
    }
    for (i = 0; i < n; i++) {
        av_bprintf(&fingerprint, "%02X", md[i]);
        if (i < n - 1)
            av_bprintf(&fingerprint, ":");
    }
    if (!fingerprint.str || !strlen(fingerprint.str)) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Fingerprint is empty\n");
        goto einval_end;
    }

    ctx->dtls_fingerprint = av_strdup(fingerprint.str);
    if (!ctx->dtls_fingerprint) {
        goto enomem_end;
    }

    goto end;
    enomem_end:
    ret = AVERROR(ENOMEM);
    goto end;
    eio_end:
    ret = AVERROR(EIO);
    goto end;
    einval_end:
    ret = AVERROR(EINVAL);
    end:
    X509_NAME_free(subject);
    av_bprint_finalize(&fingerprint, NULL);
    return ret;
}

/**
 * Initializes DTLS context using ECDHE.
 */
static av_cold int openssl_dtls_init_context(DTLSContext *ctx)
{
    int ret = 0;
    EVP_PKEY *dtls_pkey = ctx->dtls_pkey;
    X509 *dtls_cert = ctx->dtls_cert;
    SSL_CTX *dtls_ctx = NULL;
    SSL *dtls = NULL;
    BIO *bio_in = NULL, *bio_out = NULL;
    const char* ciphers = "ALL";
    /**
     * The profile for OpenSSL's SRTP is SRTP_AES128_CM_SHA1_80, see ssl/d1_srtp.c.
     * The profile for FFmpeg's SRTP is SRTP_AES128_CM_HMAC_SHA1_80, see libavformat/srtp.c.
     */
    const char* profiles = "SRTP_AES128_CM_SHA1_80";

    /* Refer to the test cases regarding these curves in the WebRTC code. */
#if OPENSSL_VERSION_NUMBER >= 0x10100000L /* OpenSSL 1.1.0 */
    const char* curves = "X25519:P-256:P-384:P-521";
#elif OPENSSL_VERSION_NUMBER >= 0x10002000L /* OpenSSL 1.0.2 */
    const char* curves = "P-256:P-384:P-521";
#endif

#if OPENSSL_VERSION_NUMBER < 0x10002000L /* OpenSSL v1.0.2 */
    dtls_ctx = ctx->dtls_ctx = SSL_CTX_new(DTLSv1_method());
#else
    dtls_ctx = ctx->dtls_ctx = SSL_CTX_new(DTLS_method());
#endif
    if (!dtls_ctx) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

#if OPENSSL_VERSION_NUMBER >= 0x10002000L /* OpenSSL 1.0.2 */
    /* For ECDSA, we could set the curves list. */
    if (SSL_CTX_set1_curves_list(dtls_ctx, curves) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Init SSL_CTX_set1_curves_list failed, curves=%s, %s\n",
               curves, openssl_get_error(ctx));
        ret = AVERROR(EINVAL);
        return ret;
    }
#endif

#if OPENSSL_VERSION_NUMBER < 0x10100000L // v1.1.x
#if OPENSSL_VERSION_NUMBER < 0x10002000L // v1.0.2
    if (ctx->dtls_eckey)
        SSL_CTX_set_tmp_ecdh(dtls_ctx, ctx->dtls_eckey);
#else
    SSL_CTX_set_ecdh_auto(dtls_ctx, 1);
#endif
#endif

    /**
     * We activate "ALL" cipher suites to align with the peer's capabilities,
     * ensuring maximum compatibility.
     */
    if (SSL_CTX_set_cipher_list(dtls_ctx, ciphers) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Init SSL_CTX_set_cipher_list failed, ciphers=%s, %s\n",
               ciphers, openssl_get_error(ctx));
        ret = AVERROR(EINVAL);
        return ret;
    }
    /* Setup the certificate. */
    if (SSL_CTX_use_certificate(dtls_ctx, dtls_cert) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Init SSL_CTX_use_certificate failed, %s\n", openssl_get_error(ctx));
        ret = AVERROR(EINVAL);
        return ret;
    }
    if (SSL_CTX_use_PrivateKey(dtls_ctx, dtls_pkey) != 1) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Init SSL_CTX_use_PrivateKey failed, %s\n", openssl_get_error(ctx));
        ret = AVERROR(EINVAL);
        return ret;
    }

    /* Server will send Certificate Request. */
    SSL_CTX_set_verify(dtls_ctx, SSL_VERIFY_PEER | SSL_VERIFY_CLIENT_ONCE, openssl_dtls_verify_callback);
    /* The depth count is "level 0:peer certificate", "level 1: CA certificate",
     * "level 2: higher level CA certificate", and so on. */
    SSL_CTX_set_verify_depth(dtls_ctx, 4);
    /* Whether we should read as many input bytes as possible (for non-blocking reads) or not. */
    SSL_CTX_set_read_ahead(dtls_ctx, 1);
    /* Setup the SRTP context */
    if (SSL_CTX_set_tlsext_use_srtp(dtls_ctx, profiles)) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Init SSL_CTX_set_tlsext_use_srtp failed, profiles=%s, %s\n",
               profiles, openssl_get_error(ctx));
        ret = AVERROR(EINVAL);
        return ret;
    }

    /* The dtls should not be created unless the dtls_ctx has been initialized. */
    dtls = ctx->dtls = SSL_new(dtls_ctx);
    if (!dtls) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    /* Setup the callback for logging. */
    SSL_set_ex_data(dtls, 0, ctx);
    SSL_set_info_callback(dtls, openssl_dtls_on_info);

    /**
     * We have set the MTU to fragment the DTLS packet. It is important to note that the
     * packet is split to ensure that each handshake packet is smaller than the MTU.
     */
    SSL_set_options(dtls, SSL_OP_NO_QUERY_MTU);
    SSL_set_mtu(dtls, ctx->mtu);
#if OPENSSL_VERSION_NUMBER >= 0x100010b0L /* OpenSSL 1.0.1k */
    DTLS_set_link_mtu(dtls, ctx->mtu);
#endif

    bio_in = BIO_new(BIO_s_mem());
    if (!bio_in) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    bio_out = BIO_new(BIO_s_mem());
    if (!bio_out) {
        ret = AVERROR(ENOMEM);
        goto end;
    }

    /**
     * Please be aware that it is necessary to use a callback to obtain the packet to be written out. It is
     * imperative that BIO_get_mem_data is not used to retrieve the packet, as it returns all the bytes that
     * need to be sent out.
     * For example, if MTU is set to 1200, and we got two DTLS packets to sendout:
     *      ServerHello, 95bytes.
     *      Certificate, 1105+143=1248bytes.
     * If use BIO_get_mem_data, it will return 95+1248=1343bytes, which is larger than MTU 1200.
     * If use callback, it will return two UDP packets:
     *      ServerHello+Certificate(Frament) = 95+1105=1200bytes.
     *      Certificate(Fragment) = 143bytes.
     * Note that there should be more packets in real world, like ServerKeyExchange, CertificateRequest,
     * and ServerHelloDone. Here we just use two packets for example.
     */
#if OPENSSL_VERSION_NUMBER < 0x30000000L // v3.0.x
    BIO_set_callback(bio_out, openssl_dtls_bio_out_callback);
#else
    BIO_set_callback_ex(bio_out, openssl_dtls_bio_out_callback_ex);
#endif
    BIO_set_callback_arg(bio_out, (char*)ctx);

    ctx->bio_in = bio_in;
    SSL_set_bio(dtls, bio_in, bio_out);
    /* Now the bio_in and bio_out are owned by dtls, so we should set them to NULL. */
    bio_in = bio_out = NULL;

    end:
    BIO_free(bio_in);
    BIO_free(bio_out);
    return ret;
}

void* dtls_context_new(AVClass *av_class, void *opaque, int pkt_size, dtls_fn_on_state on_state, dtls_fn_on_write on_write, const char* cert_file, const char* key_file)
{
    DTLSContext *ctx = av_mallocz(sizeof(DTLSContext));

    ctx->av_class = av_class;
    ctx->mtu = pkt_size;
    ctx->opaque = opaque;
    ctx->on_state = on_state;
    ctx->on_write = on_write;
    if (cert_file)
        ctx->cert_file = av_strdup(cert_file);
    if (key_file)
        ctx->key_file = av_strdup(key_file);

    return ctx;
}

/**
 * Generate a self-signed certificate and private key for DTLS. Please note that the
 * ff_openssl_init in tls_openssl.c has already called SSL_library_init(), and therefore,
 * there is no need to call it again.
 */
av_cold int dtls_context_init(AVFormatContext *s, void *pctx)
{
    DTLSContext *ctx = pctx;

    int ret = 0;

    ctx->dtls_init_starttime = av_gettime();

    if (ctx->cert_file && ctx->key_file) {
        /* Read the private key and file from the file. */
        if ((ret = openssl_read_certificate(s, ctx)) < 0) {
            av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to read DTLS certificate from cert=%s, key=%s\n",
                   ctx->cert_file, ctx->key_file);
            return ret;
        }
    } else {
        /* Generate a private key to ctx->dtls_pkey. */
        if ((ret = openssl_dtls_gen_private_key(ctx)) < 0) {
            av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to generate DTLS private key\n");
            return ret;
        }

        /* Generate a self-signed certificate. */
        if ((ret = openssl_dtls_gen_certificate(ctx)) < 0) {
            av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to generate DTLS certificate\n");
            return ret;
        }
    }

    if ((ret = openssl_dtls_init_context(ctx)) < 0) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to initialize DTLS context\n");
        return ret;
    }

    ctx->dtls_init_endtime = av_gettime();
    av_log(ctx, AV_LOG_VERBOSE, "DTLS: Setup ok, MTU=%d, fingerprint %s\n",
           ctx->mtu, ctx->dtls_fingerprint);

    return ret;
}

/**
 * Once the DTLS role has been negotiated - active for the DTLS client or passive for the
 * DTLS server - we proceed to set up the DTLS state and initiate the handshake.
 */
int dtls_context_start(void *pctx)
{
    DTLSContext *ctx = pctx;

    int ret = 0, r0, r1;
    SSL *dtls = ctx->dtls;

    ctx->dtls_handshake_starttime = av_gettime();

    /* Setup DTLS as passive, which is server role. */
    SSL_set_accept_state(dtls);

    /**
     * During initialization, we only need to call SSL_do_handshake once because SSL_read consumes
     * the handshake message if the handshake is incomplete.
     * To simplify maintenance, we initiate the handshake for both the DTLS server and client after
     * sending out the ICE response in the start_active_handshake function. It's worth noting that
     * although the DTLS server may receive the ClientHello immediately after sending out the ICE
     * response, this shouldn't be an issue as the handshake function is called before any DTLS
     * packets are received.
     */
    r0 = SSL_do_handshake(dtls);
    r1 = openssl_ssl_get_error(ctx, r0);
    // Fatal SSL error, for example, no available suite when peer is DTLS 1.0 while we are DTLS 1.2.
    if (r0 < 0 && (r1 != SSL_ERROR_NONE && r1 != SSL_ERROR_WANT_READ && r1 != SSL_ERROR_WANT_WRITE)) {
        av_log(ctx, AV_LOG_ERROR, "DTLS: Failed to drive SSL context, r0=%d, r1=%d %s\n", r0, r1, ctx->error_message);
        return AVERROR(EIO);
    }

    return ret;
}

/**
 * DTLS handshake with server, as a server in passive mode, using openssl.
 *
 * This function initializes the SSL context as the client role using OpenSSL and
 * then performs the DTLS handshake until success. Upon successful completion, it
 * exports the SRTP material key.
 *
 * @return 0 if OK, AVERROR_xxx on error
 */
int dtls_context_write(void *pctx, char* buf, int size)
{
    DTLSContext *ctx = pctx;

    int ret = 0, res_ct, res_ht, r0, r1, do_callback;
    SSL *dtls = ctx->dtls;
    const char* dst = "EXTRACTOR-dtls_srtp";
    BIO *bio_in = ctx->bio_in;

    /* Got DTLS response successfully. */
    openssl_dtls_state_trace(ctx, buf, size, 1);
    if ((r0 = BIO_write(bio_in, buf, size)) <= 0) {
        res_ct = size > 0 ? buf[0]: 0;
        res_ht = size > 13 ? buf[13] : 0;
        av_log(ctx, AV_LOG_ERROR, "DTLS: Feed response failed, content=%d, handshake=%d, size=%d, r0=%d\n",
               res_ct, res_ht, size, r0);
        ret = AVERROR(EIO);
        goto end;
    }

    /**
     * If there is data available in bio_in, use SSL_read to allow SSL to process it.
     * We limit the MTU to 1200 for DTLS handshake, which ensures that the buffer is large enough for reading.
     */
    r0 = SSL_read(dtls, buf, sizeof(buf));
    r1 = openssl_ssl_get_error(ctx, r0);
    if (r0 <= 0) {
        if (r1 != SSL_ERROR_WANT_READ && r1 != SSL_ERROR_WANT_WRITE && r1 != SSL_ERROR_ZERO_RETURN) {
            av_log(ctx, AV_LOG_ERROR, "DTLS: Read failed, r0=%d, r1=%d %s\n", r0, r1, ctx->error_message);
            ret = AVERROR(EIO);
            goto end;
        }
    } else {
        av_log(ctx, AV_LOG_TRACE, "DTLS: Read %d bytes, r0=%d, r1=%d\n", r0, r0, r1);
    }

    /* Check whether the DTLS is completed. */
    if (SSL_is_init_finished(dtls) != 1)
        goto end;

    do_callback = ctx->on_state && !ctx->dtls_done_for_us;
    ctx->dtls_done_for_us = 1;
    ctx->dtls_handshake_endtime = av_gettime();

    /* Export SRTP master key after DTLS done */
    if (!ctx->dtls_srtp_key_exported) {
        ret = SSL_export_keying_material(dtls, ctx->dtls_srtp_materials, sizeof(ctx->dtls_srtp_materials),
                                         dst, strlen(dst), NULL, 0, 0);
        r1 = openssl_ssl_get_error(ctx, r0);
        if (!ret) {
            av_log(ctx, AV_LOG_ERROR, "DTLS: SSL export key ret=%d, r1=%d %s\n", ret, r1, ctx->error_message);
            ret = AVERROR(EIO);
            goto end;
        }

        ctx->dtls_srtp_key_exported = 1;
    }

    if (do_callback && (ret = ctx->on_state(ctx, ctx->opaque, DTLS_STATE_FINISHED, NULL, NULL)) < 0)
        goto end;

    end:
    return ret;
}

/**
 * Cleanup the DTLS context.
 */
av_cold void dtls_context_deinit(void *pctx)
{
    DTLSContext *ctx = pctx;

    SSL_free(ctx->dtls);
    SSL_CTX_free(ctx->dtls_ctx);
    X509_free(ctx->dtls_cert);
    EVP_PKEY_free(ctx->dtls_pkey);
    av_freep(&ctx->dtls_fingerprint);
    av_freep(&ctx->cert_file);
    av_freep(&ctx->key_file);
#if OPENSSL_VERSION_NUMBER < 0x30000000L /* OpenSSL 3.0 */
    EC_KEY_free(ctx->dtls_eckey);
#endif
}

